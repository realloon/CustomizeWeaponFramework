# 工作台订单添加实现指南

本文档基于 Nice Inventory Tab 模组的实现方式，说明如何在武器配件模组中实现"快速在工作台添加制作订单"的功能。

## 目录

1. [获取当前世界的工作台](#获取当前世界的工作台)
2. [查找可用的配方](#查找可用的配方)
3. [创建并添加订单](#创建并添加订单)
4. [完整示例代码](#完整示例代码)

---

## 获取当前世界的工作台

### 方法一：获取指定地图的所有工作台

使用 `Map.listerBuildings.AllBuildingsColonistOfClass<Building_WorkTable>()` 可以获取指定地图上所有属于玩家的工作台：

```csharp
using RimWorld;
using Verse;

// 获取当前地图的所有工作台
Map currentMap = Find.CurrentMap; // 或者使用其他方式获取Map对象

foreach (Building_WorkTable workTable in currentMap.listerBuildings.AllBuildingsColonistOfClass<Building_WorkTable>())
{
    // 处理每个工作台
    // workTable 就是 Building_WorkTable 实例
}
```

### 方法二：获取所有地图的工作台

如果需要跨地图查找，可以遍历所有地图：

```csharp
foreach (Map map in Find.Maps)
{
    foreach (Building_WorkTable workTable in map.listerBuildings.AllBuildingsColonistOfClass<Building_WorkTable>())
    {
        // 处理每个工作台
    }
}
```

### 关键API说明

- **`Map.listerBuildings`**: 地图的建筑列表器，用于快速查找建筑
- **`AllBuildingsColonistOfClass<T>()`**: 泛型方法，返回指定类型的所有玩家建筑
- **`Building_WorkTable`**: RimWorld 的工作台基类，所有工作台都继承此类

---

## 查找可用的配方

获取工作台后，需要检查该工作台是否有能制作目标配件的配方：

```csharp
// 假设我们要查找能制作某个配件（ThingDef）的工作台
ThingDef targetAttachmentDef = YourAttachmentDef; // 你的配件定义

foreach (Building_WorkTable workTable in map.listerBuildings.AllBuildingsColonistOfClass<Building_WorkTable>())
{
    // 检查工作台是否有配方列表
    if (workTable.def.AllRecipes == null)
    {
        continue;
    }
    
    // 遍历工作台的所有配方
    foreach (RecipeDef recipe in workTable.def.AllRecipes)
    {
        // 检查配方是否可用
        if (!recipe.AvailableNow)
        {
            continue;
        }
        
        // 检查配方是否可以在该工作台上使用
        if (!recipe.AvailableOnNow(workTable, null))
        {
            continue;
        }
        
        // 检查配方制作的产品是否是我们需要的配件
        ThingDef producedThing = recipe.ProducedThingDef;
        if (producedThing != null && producedThing == targetAttachmentDef)
        {
            // 找到了！这个工作台可以制作该配件
            // workTable: 工作台实例
            // recipe: 配方定义
        }
    }
}
```

### 关键API说明

- **`workTable.def.AllRecipes`**: 工作台定义中的所有配方列表（`List<RecipeDef>`）
- **`recipe.AvailableNow`**: 配方当前是否可用（考虑科技解锁、DLC等）
- **`recipe.AvailableOnNow(workTable, null)`**: 配方是否可以在指定工作台上使用（考虑工作台状态、技能要求等）
- **`recipe.ProducedThingDef`**: 配方制作的产品定义（`ThingDef`）

---

## 创建并添加订单

找到合适的工作台和配方后，就可以创建订单并添加到工作台：

```csharp
public static void AddBillToWorkTable(Building_WorkTable workTable, RecipeDef recipe, ThingDef attachmentDef)
{
    // 参数验证
    if (workTable == null || recipe == null || attachmentDef == null)
    {
        return;
    }
    
    // 1. 创建新订单
    Bill newBill = BillUtility.MakeNewBill(recipe, null);
    
    // 2. 可选：自定义订单名称
    if (newBill is Bill_Production productionBill)
    {
        productionBill.RenamableLabel = $"制作 {attachmentDef.LabelCap}";
    }
    
    // 3. 将订单添加到工作台的订单栈
    workTable.billStack.AddBill(newBill);
    
    // 4. 可选：显示提示消息
    Messages.Message(
        $"已在 {workTable.LabelCap} 添加制作订单：{attachmentDef.LabelCap}",
        MessageTypeDefOf.TaskCompletion,
        false
    );
    
    // 5. 可选：跳转到工作台（如果工作台在当前地图）
    if (workTable.Map == Find.CurrentMap)
    {
        CameraJumper.TryJump(workTable, CameraJumper.MovementMode.None);
    }
}
```

### 关键API说明

- **`BillUtility.MakeNewBill(recipe, precept)`**: 根据配方创建新订单
  - `recipe`: 配方定义
  - `precept`: 意识形态相关，通常传 `null`
- **`workTable.billStack.AddBill(bill)`**: 将订单添加到工作台的订单栈
- **`Bill_Production.RenamableLabel`**: 可重命名的订单标签（可选）
- **`Messages.Message()`**: 显示游戏内消息提示
- **`CameraJumper.TryJump()`**: 将镜头跳转到指定目标

---

## 完整示例代码

以下是一个完整的工具类示例，展示了如何查找可制作指定配件的工作台并添加订单：

```csharp
using System.Collections.Generic;
using RimWorld;
using Verse;

namespace YourModNamespace
{
    public static class AttachmentCraftingUtility
    {
        /// <summary>
        /// 查找所有能制作指定配件的工作台和配方
        /// </summary>
        /// <param name="attachmentDef">配件定义</param>
        /// <param name="map">目标地图（如果为null则使用当前地图）</param>
        /// <returns>工作台和配方的配对列表</returns>
        public static List<(Building_WorkTable workTable, RecipeDef recipe)> 
            FindWorkTablesForAttachment(ThingDef attachmentDef, Map map = null)
        {
            List<(Building_WorkTable, RecipeDef)> results = new List<(Building_WorkTable, RecipeDef)>();
            
            if (attachmentDef == null)
            {
                return results;
            }
            
            if (map == null)
            {
                map = Find.CurrentMap;
            }
            
            if (map == null)
            {
                return results;
            }
            
            // 遍历所有工作台
            foreach (Building_WorkTable workTable in map.listerBuildings.AllBuildingsColonistOfClass<Building_WorkTable>())
            {
                if (workTable.def.AllRecipes == null)
                {
                    continue;
                }
                
                // 遍历工作台的所有配方
                foreach (RecipeDef recipe in workTable.def.AllRecipes)
                {
                    // 检查配方是否可用
                    if (!recipe.AvailableNow)
                    {
                        continue;
                    }
                    
                    // 检查配方是否可以在该工作台上使用
                    if (!recipe.AvailableOnNow(workTable, null))
                    {
                        continue;
                    }
                    
                    // 检查配方制作的产品是否是我们需要的配件
                    ThingDef producedThing = recipe.ProducedThingDef;
                    if (producedThing != null && producedThing == attachmentDef)
                    {
                        results.Add((workTable, recipe));
                    }
                }
            }
            
            return results;
        }
        
        /// <summary>
        /// 在工作台添加制作订单
        /// </summary>
        /// <param name="workTable">工作台</param>
        /// <param name="recipe">配方</param>
        /// <param name="attachmentDef">配件定义（用于显示消息）</param>
        /// <param name="showMessage">是否显示提示消息</param>
        /// <param name="jumpToWorkTable">是否跳转到工作台</param>
        /// <returns>是否成功添加</returns>
        public static bool AddCraftingBill(
            Building_WorkTable workTable, 
            RecipeDef recipe, 
            ThingDef attachmentDef,
            bool showMessage = true,
            bool jumpToWorkTable = true)
        {
            // 参数验证
            if (workTable == null || recipe == null || attachmentDef == null)
            {
                return false;
            }
            
            // 创建新订单
            Bill newBill = BillUtility.MakeNewBill(recipe, null);
            
            // 可选：自定义订单名称
            if (newBill is Bill_Production productionBill)
            {
                productionBill.RenamableLabel = $"制作 {attachmentDef.LabelCap}";
            }
            
            // 添加订单到工作台
            workTable.billStack.AddBill(newBill);
            
            // 显示提示消息
            if (showMessage)
            {
                Messages.Message(
                    $"已在 {workTable.LabelCap} 添加制作订单：{attachmentDef.LabelCap}",
                    MessageTypeDefOf.TaskCompletion,
                    false
                );
            }
            
            // 跳转到工作台
            if (jumpToWorkTable && workTable.Map == Find.CurrentMap)
            {
                CameraJumper.TryJump(workTable, CameraJumper.MovementMode.None);
            }
            
            return true;
        }
        
        /// <summary>
        /// 为指定配件查找工作台并添加订单（自动选择第一个可用工作台）
        /// </summary>
        /// <param name="attachmentDef">配件定义</param>
        /// <param name="map">目标地图</param>
        /// <returns>是否成功添加</returns>
        public static bool AddCraftingBillForAttachment(ThingDef attachmentDef, Map map = null)
        {
            var workTables = FindWorkTablesForAttachment(attachmentDef, map);
            
            if (workTables.Count == 0)
            {
                Messages.Message(
                    $"未找到能制作 {attachmentDef.LabelCap} 的工作台",
                    MessageTypeDefOf.RejectInput,
                    false
                );
                return false;
            }
            
            // 使用第一个找到的工作台
            var (workTable, recipe) = workTables[0];
            return AddCraftingBill(workTable, recipe, attachmentDef);
        }
    }
}
```

### 使用示例

```csharp
// 示例1：查找能制作某个配件的工作台
ThingDef scopeDef = YourModDefOf.AttachmentScope; // 你的瞄准镜定义
var workTables = AttachmentCraftingUtility.FindWorkTablesForAttachment(scopeDef);

// 示例2：直接添加订单（自动选择第一个可用工作台）
AttachmentCraftingUtility.AddCraftingBillForAttachment(scopeDef);

// 示例3：在指定工作台添加订单
Building_WorkTable workbench = someWorkbench;
RecipeDef recipe = someRecipe;
AttachmentCraftingUtility.AddCraftingBill(workbench, recipe, scopeDef);
```

---

## 注意事项

1. **地图检查**: 确保在访问 `map.listerBuildings` 前检查 `map` 不为 `null`
2. **配方可用性**: 必须同时检查 `AvailableNow` 和 `AvailableOnNow`，两者都返回 `true` 才能使用
3. **订单类型**: `BillUtility.MakeNewBill` 返回的是 `Bill` 基类，如果需要访问特定属性（如 `RenamableLabel`），需要进行类型转换
4. **多工作台处理**: 如果一个配件可以在多个工作台制作，建议让玩家选择，或者按优先级选择（如距离、效率等）
5. **错误处理**: 建议添加适当的错误处理和用户提示

---

## 扩展建议

1. **优先级排序**: 可以根据工作台距离、效率等因素对工作台进行排序
2. **批量添加**: 支持一次添加多个配件的制作订单
3. **条件过滤**: 添加更多过滤条件（如工作台是否被占用、是否有足够材料等）
4. **UI集成**: 在武器配件界面中集成此功能，类似 Nice Inventory Tab 的实现方式

---

## 参考来源

本文档基于以下模组的实现方式：
- **Nice Inventory Tab** - 装备界面优化模组
- 参考文件：
  - `CraftingUtility.cs` - 工作台查找逻辑
  - `CommandUtility.cs` - 订单添加逻辑

